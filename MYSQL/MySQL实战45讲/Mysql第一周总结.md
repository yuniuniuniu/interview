##### 一条SQL查询语句的执行过程：

![0d2070e8f84c4801adbfa03bda1f98d9](C:\Users\54456\Desktop\pic\0d2070e8f84c4801adbfa03bda1f98d9.png)

首先要通过连接器连接到数据库上，它负责建立连接（Tcp握手）以及对权限进行验证，之后这个连接中的所有权限判断逻辑，都依赖于此时读到的权限。

接下来拿到一个查询请求后，会先到查询缓存中看看之前是不是执行过这条语句，如果执行过，可能会以key-value存储，如果命中，就直接返回结果；反之继续后续并将查询结果放入缓存中。

ps：对一个表进行更新后，这个表上的所有查询缓存都会被清空，所以对非静态表一般不用（Mysql8.0开始取消）

接着，进入分析器，对SQL语句进行解析，先进行词法分析，对字符串进行识别；然后语法分析，根据词法分析的结果判断这个SQL语句是否满足MySQL语句

接着，进入优化器，优化器在表中有多个索引的时候决定用哪个索引以及多表关联的时候，决定表之间的连接顺序（逻辑结果相同，但是执行效率不同，优化器选择）

接着，进入执行器，要先判断对表有没有查询的权限（如果是查询缓存命中，则在返回结果的时候，做权限验证），如果有权限，那么就去使用引擎提供的接口执行查询



##### 一条SQL更新语句执行过程：

与查询类似，重要内容是redo log 以及 binlog

**redo log：**

当有一条记录需要更新的时候，InnoDB先将记录写到redo log中，并更新内存，并在适当的时候，将记录更新到磁盘之中

redo log一般是固定大小的，如一组四个文件，每个文件1GB，从头开始写，写到末尾又回到开头循环写。

![b075250cad8d9f6c791a52b6a600f69c](C:\Users\54456\Desktop\pic\b075250cad8d9f6c791a52b6a600f69c.jpg)

write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下（擦除指的是写进硬盘）

有了redo log，就保证了之前提交的记录在异常重启时候不会丢失，这就是crash-safe



**binlog**

binlog以及redo log之间的不同点：

1、redo log是引擎层的，binlog是server层的（没有crash safe能力）

2、redo log是物理日志，记录的是具体修改，binlog是逻辑日志，记录的是sql或者更新前后的row

3、redo循环写，会用完；bin追加写，不会用完



**两阶段提交过程：**

![2e5bff4910ec189fe1ee6e2ecc7b4bbe](C:\Users\54456\Desktop\pic\2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

（如果在写binlog时候发生异常断开，那么事务就会回滚，相当于redolog写入也失败了；如果在写binlog之后断开，这时同时满足prepare以及binlog完整，所以重启后自动commit）



**事务隔离：**

四个级别包括 

- 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交：一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

数据库中会创建一个视图，访问的时候以视图的逻辑结果为准，“可重复读”视图在事务启动的时候创建；“读提交”在每个sql语句开始执行的时候创建；其余两个没视图概念

事务隔离中可重复读的实现：

每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，可以通过回滚操作，得到前一个状态的值。

![2021-06-21_112156](C:\Users\54456\Desktop\pic\2021-06-21_112156.png)

同一条记录在系统中可以存在多个版本，这就是多并发版本控制（MVCC）。

系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除（系统里没有比这个回滚日志更早的read-view的时候）



长事务的潜在风险：

长事务的话其中的read view就会存在很老的，这样回滚日志就会很大。



Mysql事务启动方式：

1、显式启动,begin或start transaction。提交语句commit，回滚语句 rollback

2、set autocommit=0，这会使线程的自动提交关闭，意味着只执行一个select语句，这个事务就启动了，并且不会自动提交。事务持续存在于主动执行commit或者rollback语句，或者断开连接



**索引：**

哈希表这种结构适用于只有等值查询的场景，有序数组在等值查询和范围查询都适用，但是更新数据麻烦，适合静态存储引擎。

InnoDB索引模型是B+树模型，根据叶子节点内容，索引类型分为主键索引和非主键索引。主键索引叶子节点存的是整行数据；非主键索引（二级索引）叶子节点存的是主键的值，要多扫描一棵索引树。

自增主键在建表语句中一般定义为：NOT NULL PRIMARY KEY AUTO _INCREMENT。在每次操作都是追加插入的时候，可以用它。



联合索引创建过程，就是按照第一个索引进行建树，然后其他索引在数据段中



**全局锁和表锁**

全局锁

MySQL提供了加全局锁的方法，命令是Flush tables with read lock(FTWRL)，当需要让整个库处于只读状态的时候，可以使用这个命令。典型场景就是全库逻辑备份。

官方自带一个逻辑备份工具mysqldump，当它用参数-single-transaction的时候，会在导数据之前启动一个事务，来保证拿到一致性视图。（只适用于所有的表使用了事务引擎的库）



表级锁（包括表锁及元数据锁）

表锁：lock tables ... read/write，可以用unlock tables主动释放，也可以在客户端断开自动释放，会限制其他线程读写；会限制本线程接下来的操作对象

元数据锁（metadata lock）：是系统默认会加的，用于保证读写的正确性（在语句执行开始时执行，语句结束后不会马上释放，会等到整个事务提交后再释放）



**行锁（InnoDB）**

在事务中，行锁在需要的时候加上，等到事务结束的时候才释放，因此假如事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。



死锁和死锁检测

![2021-06-22_155016](C:\Users\54456\Desktop\pic\2021-06-22_155016.png)

id为1和2的行锁都被占用，互相请求释放，因此陷入死锁

解决方法

一是直接进入等待，知道超时。超时时间由innodb_lock_wait_timeout设置

二是发起死锁检测，发现死锁后，主动回滚死锁链中的某一个事务，让其他事务得以继续执行。将innodb_deadlock_detect设置为on，表示开启这个逻辑





